(load "bool.ss")
(load "list.ss")

(define read
  (let ((char->digit (lambda (c)
                       (define res
                         (assoc c '((#\0 . 0) (#\1 . 1) (#\2 . 2) (#\3 . 3) (#\4 . 4)
                                    (#\5 . 5) (#\6 . 6) (#\7 . 7) (#\8 . 8) (#\9 . 9))))
                       (and res (cdr res))))
        (digit? (lambda (c)
                  (not (not (char->digit c)))))
        (whitespace? (lambda (c)
                       (memq c '(#\space #\tab #\newline #\return))))
        (skip-char (lambda (in)
                     (void (read-char in))))
        (skip-line (lambda (in)
                     (let loop ((c (read-char in)))
                       (unless (equal? c #\newline)
                         (loop (read-char in))))))
        (read-word (lambda (in)
                     (let loop ((cs null))
                       (define c (peek-char in))
                       (cond
                        ((or (equal? c #\()
                             (equal? c #\))
                             (whitespace? c))
                         (reverse cs))
                        (#t
                         (loop (cons (read-char in) cs)))))))
        (read-list (lambda (in)
                     (let loop ((xs null))
                       (cond
                        ((equal? (peek-char in) #\))
                         (skip-char in)
                         (reverse xs))
                        (#t
                         (loop (cons (read in) xs)))))))
        (read-bool (lambda (in)
                     (define c (read-char in))
                     (cond
                      ((equal? c #\t) #t)
                      ((equal? c #\f) #f)
                      (#t (error 'read-bool (format "unexpected character ~s" c))))))
        (read-character (lambda (in)
                          (define cs (read-word in))
                          (cond
                           ((= (length cs) 1) (car cs))
                           (#t
                            (define special
                              (assoc (string->symbol (apply string cs))
                                     '((space . #\space)
                                       (tab . #\tab)
                                       (newline . #\newline)
                                       (return . #\return))))
                            (unless special
                              (error 'read-character (format "bad character: ~s" cs)))
                            (cdr special)))))
        (read-string (lambda (in)
                       (let loop ((cs null)
                                  (escaped? #f))
                         (define c (read-char in))
                         (if (and (not escaped?) (equal? c #\"))
                             (apply string (reverse cs))
                             (loop (cons c cs) (equal? c #\\))))))
        (read-number (lambda (in)
                       ;; TODO: Floats
                       (define c (read-char in))
                       (cond
                        ((equal? c #\0) 0)
                        (#t
                         (let loop ((n (char->digit c)))
                           (define nc (peek-char in))
                           (if (digit? nc)
                               (loop (+ (* n 10) (char->digit (read-char in))))
                               n))))))
        (read-symbol (lambda (in)
                       (string->symbol (apply string (read-word in))))))
    (lambda (in)
      (define c (peek-char in))
      (cond
       ((eof-object? c) eof)
       ((whitespace? c)
        (skip-char in)
        (read in))
       ((equal? c #\;)
        (skip-line in)
        (read in))
       ((equal? c #\')
        (skip-char in)
        `(quote ,(read in)))
       ((equal? c #\`)
        (skip-char in)
        `(quasiquote ,(read in)))
       ((equal? c #\,)
        (skip-char in)
        (define kind
          (cond
           ((equal? (peek-char in) #\@)
            (skip-char in)
            'unquote-splicing)
           (#t 'unquote)))
        (cons kind (read in)))
       ((equal? c #\()
        (skip-char in)
        (read-list in))
       ((equal? c #\#)
        (skip-char in)
        (cond
         ((equal? (peek-char in) #\\)
          (skip-char in)
          (read-character in))
         (#t
          (read-bool in))))
       ((equal? c #\")
        (skip-char in)
        (read-string in))
       ((digit? c)
        (read-number in))
       (#t
        (read-symbol in))))))
